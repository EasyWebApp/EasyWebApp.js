//
//  Generated by https://www.npmjs.com/package/amd-bundle
//
(function (factory) {

    if ((typeof define === 'function')  &&  define.amd)
        define('EWA', factory);
    else if (typeof module === 'object')
        module.exports = factory();
    else
        this.EWA = factory();

})(function () {


var Component = (function (exports) {'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _private_ = exports._private_ = new WeakMap();

/**
 * Utility methods of Web Component
 */

var Component = function () {
    function Component() {
        _classCallCheck(this, Component);
    }

    _createClass(Component, [{
        key: 'attributeChangedCallback',
        value: function attributeChangedCallback(name, oldValue, newValue) {

            switch (newValue) {
                case '':
                    this[name] = true;break;
                case null:
                    this[name] = false;break;
                default:
                    try {
                        this[name] = JSON.parse(newValue);
                    } catch (error) {

                        this[name] = newValue;
                    }
            }
        }

        /**
         * @param {Element} element
         *
         * @return {number} The index of `element` in its siblings
         */

    }, {
        key: '$',


        /**
         * @param {string} selector
         *
         * @return {Element[]} Element set which matches `selector` in this Shadow DOM
         */
        value: function $(selector) {

            return [].concat(_toConsumableArray(this.shadowRoot.querySelectorAll(selector)));
        }
    }], [{
        key: 'setAccessor',


        /**
         * Define a set of Getter or Setter for DOM properties,
         * and store their values into private object.
         *
         * @param {Object} map - `1` for Getter, `2` for Setter & sum for both
         *                       in each key's value
         * @return {string[]} Keys of `map`
         *
         * @example
         *
         *    EWA.component(class MyInput extends HTMLElement {
         *
         *        constructor() {  super();  }
         *
         *        static get observedAttributes() {
         *
         *            return this.setAccessor({
         *                value:  1,
         *                step:   3
         *            });
         *        }
         *    });
         */
        value: function setAccessor(map) {
            var _this = this;

            var _loop = function _loop(key) {

                var config = { enumerable: true };

                if (map[key] & 1) config.get = function () {

                    return _private_.get(this)[key];
                };

                if (map[key] & 2) config.set = function (value) {

                    _private_.get(this)[key] = value;
                };

                Object.defineProperty(_this.prototype, key, config);
            };

            for (var key in map) {
                _loop(key);
            }

            return Object.keys(map);
        }
    }, {
        key: 'indexOf',
        value: function indexOf(element) {

            var index = 0;

            while (element = element.previousElementSibling) {
                index++;
            }return index;
        }

        /**
         * @param {Event} event
         *
         * @return {Element} The target of `event` object (**Shadow DOM** is in account)
         */

    }, {
        key: 'targetOf',
        value: function targetOf(event) {

            var target = event.composedPath ? event.composedPath() : event.path;

            return (target || '')[0] || event.target;
        }

        /**
         * @protected
         */

    }, {
        key: 'findTemplate',
        value: function findTemplate() {

            var script = document.currentScript,
                template,
                style = [];

            var element = script,
                stop;

            while (!stop && (element = element.previousElementSibling)) {
                switch (element.tagName.toLowerCase()) {
                    case 'template':
                        template = element;break;
                    case 'style':
                        style.unshift(element);break;
                    case 'link':
                        if (element.rel === 'stylesheet') {

                            element.setAttribute('href', element.href);

                            style.unshift(element);
                        }
                        break;
                    case 'script':
                        stop = true;
                }
            }return { template: template, style: style, script: script };
        }
    }, {
        key: 'tagName',

        /**
         * @type {string} - `tagName` of a Custom Element
         */
        get: function get() {

            return this.name.replace(/[A-Z]/g, function (char) {
                return '-' + char.toLowerCase();
            }).slice(1);
        }
    }]);

    return Component;
}();

exports.default = Component;
    return exports;

})({ });


var utility = (function (exports) {'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extend = extend;
exports.mapTree = mapTree;
/**
 * Merge own properties of two or more objects together into the first object
 * by their descriptor
 *
 * @param {Object}    target - An object that will receive the new properties
 *                             if `source` are passed in
 * @param {...Object} source - Additional objects containing properties to merge in
 *
 * @return {Object} The `target` parameter
 */
function extend(target) {
    for (var _len = arguments.length, source = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        source[_key - 1] = arguments[_key];
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {

        for (var _iterator = source[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var object = _step.value;
            if (object instanceof Object) {

                var descriptor = Object.getOwnPropertyDescriptors(object);

                if (target instanceof Function) {

                    delete descriptor.name;
                    delete descriptor.length;
                    delete descriptor.prototype;

                    Object.defineProperties(target.prototype, Object.getOwnPropertyDescriptors(object.prototype));
                }

                Object.defineProperties(target, descriptor);
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return target;
}

var depth = 0;

/**
 * Traverse Object-tree & return Node array through the filter
 *
 * @param {object}        node     - Object tree
 * @param {string}        fork_key - Key of children list
 * @param {MapTreeFilter} filter   - Map filter
 *
 * @return {Array}  Result list of Map filter
 */
function mapTree(node, fork_key, filter) {

    var children = node[fork_key],
        list = [];depth++;

    for (var i = 0, value; i < children.length; i++) {
        /**
         * @typedef {function} MapTreeFilter
         *
         * @param {object} child
         * @param {number} index
         * @param {number} depth
         *
         * @return {?object}  `Null` or `Undefined` to **Skip the Sub-Tree**,
         *                    and Any other Type to Add into the Result Array.
         */
        try {
            value = filter.call(node, children[i], i, depth);
        } catch (error) {

            depth = 0;throw error;
        }

        if (!(value != null)) continue;

        list.push(value);

        if (children[i] != null && (children[i][fork_key] || '')[0]) list.push.apply(list, mapTree(children[i], fork_key, filter));
    }

    depth--;

    return list;
}
    return exports;

})({ });


return  (function (exports, _Component, _utility) {'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.component = component;
exports.set = set;
exports.get = get;


var _Component2 = _interopRequireDefault(_Component);


function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Register a component
 *
 * @param {function} subClass
 *
 * @return {function} A proxy class of `subClass`
 */
function component(subClass) {
    var _template;

    var _Component$findTempla = _Component2.default.findTemplate(),
        template = _Component$findTempla.template,
        style = _Component$findTempla.style;

    template = template.content;

    if (style[0]) (_template = template).prepend.apply(_template, _toConsumableArray(style));

    subClass = new Proxy((0, _utility.extend)(subClass, _Component2.default), {
        construct: function construct(target, argument, newTarget) {

            var _this_ = Reflect.construct(target, argument, newTarget);

            _Component._private_.set(_this_, {});

            _this_.attachShadow({
                mode: 'open',
                delegatesFocus: true
            }).appendChild(template.cloneNode(true));

            return _this_;
        }
    });

    customElements.define(subClass.tagName, subClass);

    return subClass;
}

/**
 * Set private data of an HTMLElement
 *
 * @param {Element} element
 * @param {string}  key
 * @param {*}       value
 *
 * @return {*} The `value` parameter
 */
function set(element, key, value) {

    return _Component._private_.get(element)[key] = value;
}

/**
 * Get private data of an HTMLElement
 *
 * @param {Element} element
 * @param {string}  key
 *
 * @return {*}
 */
function get(element, key) {

    return _Component._private_.get(element)[key];
}
    return exports;

})({ }, Component, utility);
});